/**
 * Alert System
 * Task 014: Monitoring and Logging Systems - Automated Alerts
 * 
 * Features:
 * - Performance alerts (response time, error rate, throughput)
 * - Availability alerts (service down, degraded performance)
 * - Usage alerts (quota exceeded, high usage spikes)
 * - System health alerts (resource exhaustion, connectivity issues)
 * - Multi-channel notifications (console, email, webhook)
 */

import { getMetricsCollector, MetricsCollector } from './MetricsCollector';
import { getStructuredLogger, StructuredLogger } from './StructuredLogger';

interface AlertRule {
  id: string;
  name: string;
  description: string;
  category: 'performance' | 'availability' | 'usage' | 'system_health' | 'security';
  severity: 'low' | 'medium' | 'high' | 'critical';
  
  // Trigger conditions
  metricType: 'usage' | 'performance' | 'quality' | 'business';
  metricName: string;
  condition: 'greater_than' | 'less_than' | 'equals' | 'not_equals' | 'change_percent';
  threshold: number;
  
  // Time window for evaluation
  evaluationWindow: 'last_5min' | 'last_15min' | 'last_30min' | 'last_1hour';
  
  // Alert behavior
  cooldownMinutes: number; // Minimum time between same alerts
  escalationRules?: EscalationRule[];
  
  // Notification channels
  notificationChannels: ('console' | 'email' | 'webhook' | 'slack')[];
  
  // Additional metadata
  tags: Record<string, string>;
  enabled: boolean;
  createdAt: Date;
  lastTriggered?: Date;
}

interface EscalationRule {
  afterMinutes: number;
  severity: 'medium' | 'high' | 'critical';
  additionalChannels: string[];
}

interface AlertEvent {
  id: string;
  ruleId: string;
  ruleName: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  category: string;
  message: string;
  
  // Trigger details
  metricValue: number;
  threshold: number;
  condition: string;
  
  // Timing
  triggeredAt: Date;
  resolvedAt?: Date;
  acknowledgedAt?: Date;
  acknowledgedBy?: string;
  
  // Context
  context: {
    metricType: string;
    metricName: string;
    evaluationWindow: string;
    additionalData?: Record<string, any>;
  };
  
  // Notification tracking
  notificationsSent: {
    channel: string;
    sentAt: Date;
    success: boolean;
    error?: string;
  }[];
  
  // Escalation tracking
  escalationLevel: number;
  lastEscalationAt?: Date;
}

interface NotificationChannel {
  name: string;
  type: 'console' | 'email' | 'webhook' | 'slack';
  config: Record<string, any>;
  enabled: boolean;
}

/**
 * Alert Rule Manager
 * Manages alert rules and their evaluation
 */
class AlertRuleManager {
  private rules: Map<string, AlertRule> = new Map();

  constructor() {
    this.initializeDefaultRules();
  }

  /**
   * Í∏∞Î≥∏ ÏïåÎ¶º Í∑úÏπô Ï¥àÍ∏∞Ìôî
   */
  private initializeDefaultRules(): void {
    const defaultRules: Omit<AlertRule, 'id' | 'createdAt'>[] = [
      // Performance alerts
      {
        name: 'High Response Time',
        description: 'Average response time exceeds 2 minutes',
        category: 'performance',
        severity: 'high',
        metricType: 'performance',
        metricName: 'averageResponseTime',
        condition: 'greater_than',
        threshold: 120000, // 2 minutes in ms
        evaluationWindow: 'last_15min',
        cooldownMinutes: 10,
        notificationChannels: ['console', 'webhook'],
        tags: { component: 'image_generation' },
        enabled: true,
        escalationRules: [
          { afterMinutes: 30, severity: 'critical', additionalChannels: ['email'] }
        ]
      },
      
      {
        name: 'Low Cache Hit Rate',
        description: 'Cache hit rate below 5%',
        category: 'performance',
        severity: 'medium',
        metricType: 'performance',
        metricName: 'cacheHitRate',
        condition: 'less_than',
        threshold: 0.05, // 5%
        evaluationWindow: 'last_30min',
        cooldownMinutes: 30,
        notificationChannels: ['console'],
        tags: { component: 'cache' },
        enabled: true
      },

      // Availability alerts
      {
        name: 'High Queue Length',
        description: 'Queue length exceeds 50 items',
        category: 'availability',
        severity: 'medium',
        metricType: 'performance',
        metricName: 'averageQueueLength',
        condition: 'greater_than',
        threshold: 50,
        evaluationWindow: 'last_15min',
        cooldownMinutes: 15,
        notificationChannels: ['console', 'webhook'],
        tags: { component: 'queue' },
        enabled: true,
        escalationRules: [
          { afterMinutes: 30, severity: 'high', additionalChannels: ['email'] }
        ]
      },

      // Usage alerts
      {
        name: 'High Daily Usage',
        description: 'Daily generation count exceeds normal patterns',
        category: 'usage',
        severity: 'medium',
        metricType: 'usage',
        metricName: 'totalGenerations',
        condition: 'greater_than',
        threshold: 1000, // 1000 generations
        evaluationWindow: 'last_1hour',
        cooldownMinutes: 60,
        notificationChannels: ['console'],
        tags: { component: 'usage_monitoring' },
        enabled: true
      },

      {
        name: 'Quota Exceeded Events',
        description: 'High number of quota exceeded events',
        category: 'usage',
        severity: 'medium',
        metricType: 'usage',
        metricName: 'quotaExceededEvents',
        condition: 'greater_than',
        threshold: 10, // 10 events
        evaluationWindow: 'last_15min',
        cooldownMinutes: 30,
        notificationChannels: ['console'],
        tags: { component: 'quota_management' },
        enabled: true
      },

      // System health alerts
      {
        name: 'High Timeout Rate',
        description: 'Timeout rate exceeds 5%',
        category: 'system_health',
        severity: 'high',
        metricType: 'performance',
        metricName: 'timeoutRate',
        condition: 'greater_than',
        threshold: 0.05, // 5%
        evaluationWindow: 'last_15min',
        cooldownMinutes: 10,
        notificationChannels: ['console', 'webhook'],
        tags: { component: 'system' },
        enabled: true
      },

      {
        name: 'Connection Pool Saturation',
        description: 'Connection pool usage above 90%',
        category: 'system_health',
        severity: 'medium',
        metricType: 'performance',
        metricName: 'connectionPoolEfficiency',
        condition: 'greater_than',
        threshold: 90, // 90%
        evaluationWindow: 'last_15min',
        cooldownMinutes: 20,
        notificationChannels: ['console'],
        tags: { component: 'connection_pool' },
        enabled: true
      }
    ];

    for (const rule of defaultRules) {
      this.addRule(rule);
    }

    console.log(`üìã Initialized ${defaultRules.length} default alert rules`);
  }

  /**
   * ÏïåÎ¶º Í∑úÏπô Ï∂îÍ∞Ä
   */
  addRule(rule: Omit<AlertRule, 'id' | 'createdAt'>): string {
    const id = `rule_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;
    const fullRule: AlertRule = {
      ...rule,
      id,
      createdAt: new Date()
    };

    this.rules.set(id, fullRule);
    console.log(`üìã Added alert rule: ${rule.name} (${id})`);
    return id;
  }

  /**
   * Î™®Îì† ÌôúÏÑ± Í∑úÏπô Ï°∞Ìöå
   */
  getActiveRules(): AlertRule[] {
    return Array.from(this.rules.values()).filter(rule => rule.enabled);
  }

  /**
   * ÏïåÎ¶º Í∑úÏπô Ï°∞Ìöå
   */
  getRule(id: string): AlertRule | null {
    return this.rules.get(id) || null;
  }

  /**
   * Í∑úÏπô ÎßàÏßÄÎßâ Ìä∏Î¶¨Í±∞ ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏
   */
  updateLastTriggered(id: string): void {
    const rule = this.rules.get(id);
    if (rule) {
      rule.lastTriggered = new Date();
      this.rules.set(id, rule);
    }
  }

  /**
   * Ïø®Îã§Ïö¥ ÌôïÏù∏
   */
  isInCooldown(rule: AlertRule): boolean {
    if (!rule.lastTriggered) return false;
    
    const cooldownEndTime = new Date(rule.lastTriggered.getTime() + rule.cooldownMinutes * 60 * 1000);
    return new Date() < cooldownEndTime;
  }
}

/**
 * Alert Evaluator
 * Evaluates alert rules against current metrics
 */
class AlertEvaluator {
  private metricsCollector: MetricsCollector;

  constructor(metricsCollector: MetricsCollector) {
    this.metricsCollector = metricsCollector;
  }

  /**
   * ÏïåÎ¶º Í∑úÏπô ÌèâÍ∞Ä
   */
  async evaluateRule(rule: AlertRule): Promise<{ triggered: boolean; value?: number; message?: string }> {
    try {
      // Î©îÌä∏Î¶≠ Í∞í Ï°∞Ìöå
      const metricValue = await this.getMetricValue(rule);
      
      if (metricValue === null) {
        return { triggered: false };
      }

      // Ï°∞Í±¥ ÌèâÍ∞Ä
      const triggered = this.evaluateCondition(rule, metricValue);
      
      if (triggered) {
        const message = this.generateAlertMessage(rule, metricValue);
        return { triggered: true, value: metricValue, message };
      }

      return { triggered: false, value: metricValue };
    } catch (error) {
      console.error(`Error evaluating rule ${rule.name}:`, error);
      return { triggered: false };
    }
  }

  /**
   * Î©îÌä∏Î¶≠ Í∞í Ï°∞Ìöå
   */
  private async getMetricValue(rule: AlertRule): Promise<number | null> {
    const timeWindow = this.convertEvaluationWindow(rule.evaluationWindow);
    
    try {
      // Î©îÌä∏Î¶≠ ÌÉÄÏûÖÏóê Îî∞Îùº Ï†ÅÏ†àÌïú ÏàòÏßë Î©îÏÑúÎìú Ìò∏Ï∂ú
      switch (rule.metricType) {
        case 'usage':
          const usageMetrics = await this.metricsCollector.collectUsageMetrics(timeWindow);
          return this.extractMetricValue(usageMetrics, rule.metricName);
          
        case 'performance':
          const performanceMetrics = await this.metricsCollector.collectPerformanceMetrics(timeWindow);
          return this.extractMetricValue(performanceMetrics, rule.metricName);
          
        case 'quality':
          // Quality metricsÎäî Ïã§ÏãúÍ∞Ñ Î©îÌä∏Î¶≠ÏóêÏÑú Ï°∞Ìöå
          const realTimeMetrics = this.metricsCollector.getRealTimeMetrics();
          return this.extractRealtimeMetricValue(realTimeMetrics, rule.metricName);
          
        case 'business':
          // Business metrics Ï°∞Ìöå (Ìñ•ÌõÑ Íµ¨ÌòÑ)
          return 0; // Placeholder
          
        default:
          return null;
      }
    } catch (error) {
      console.error(`Error getting metric value for ${rule.metricName}:`, error);
      return null;
    }
  }

  /**
   * ÌèâÍ∞Ä ÏúàÎèÑÏö∞ Î≥ÄÌôò
   */
  private convertEvaluationWindow(window: string): 'last_hour' | 'last_24h' | 'last_7d' | 'last_30d' {
    switch (window) {
      case 'last_5min':
      case 'last_15min':
      case 'last_30min':
      case 'last_1hour':
        return 'last_hour';
      default:
        return 'last_hour';
    }
  }

  /**
   * Î©îÌä∏Î¶≠ Í∞ùÏ≤¥ÏóêÏÑú ÌäπÏ†ï Í∞í Ï∂îÏ∂ú
   */
  private extractMetricValue(metrics: any, metricName: string): number | null {
    // Ï§ëÏ≤©Îêú Í∞ùÏ≤¥ÏóêÏÑú Î©îÌä∏Î¶≠ Í∞í Ï∞æÍ∏∞
    const keys = metricName.split('.');
    let value = metrics;
    
    for (const key of keys) {
      if (value && typeof value === 'object' && key in value) {
        value = value[key];
      } else {
        return null;
      }
    }
    
    return typeof value === 'number' ? value : null;
  }

  /**
   * Ïã§ÏãúÍ∞Ñ Î©îÌä∏Î¶≠ÏóêÏÑú Í∞í Ï∂îÏ∂ú
   */
  private extractRealtimeMetricValue(realTimeMetrics: any, metricName: string): number | null {
    // ÌäπÏ†ï Î©îÌä∏Î¶≠ Ïù¥Î¶Ñ Ï≤òÎ¶¨
    if (metricName === 'errorRate') {
      const successRate = realTimeMetrics.current.successRate;
      return successRate ? 1 - successRate : null;
    }
    
    // Í∏∞ÌÉÄ Î©îÌä∏Î¶≠
    return this.extractMetricValue(realTimeMetrics.current, metricName);
  }

  /**
   * Ï°∞Í±¥ ÌèâÍ∞Ä
   */
  private evaluateCondition(rule: AlertRule, value: number): boolean {
    switch (rule.condition) {
      case 'greater_than':
        return value > rule.threshold;
      case 'less_than':
        return value < rule.threshold;
      case 'equals':
        return Math.abs(value - rule.threshold) < 0.001; // Float comparison
      case 'not_equals':
        return Math.abs(value - rule.threshold) >= 0.001;
      case 'change_percent':
        // Î≥ÄÌôîÏú® Í≥ÑÏÇ∞ (Ìñ•ÌõÑ Íµ¨ÌòÑ ÌïÑÏöî)
        return false;
      default:
        return false;
    }
  }

  /**
   * ÏïåÎ¶º Î©îÏãúÏßÄ ÏÉùÏÑ±
   */
  private generateAlertMessage(rule: AlertRule, value: number): string {
    const formattedValue = this.formatMetricValue(rule.metricName, value);
    const formattedThreshold = this.formatMetricValue(rule.metricName, rule.threshold);
    
    return `${rule.name}: ${formattedValue} ${rule.condition.replace('_', ' ')} ${formattedThreshold}`;
  }

  /**
   * Î©îÌä∏Î¶≠ Í∞í Ìè¨Îß∑ÌåÖ
   */
  private formatMetricValue(metricName: string, value: number): string {
    if (metricName.includes('time') || metricName.includes('duration') || metricName.includes('Time')) {
      // ÏãúÍ∞Ñ Î©îÌä∏Î¶≠ÏùÄ Î∞ÄÎ¶¨Ï¥àÎ•º Ï¥àÎ°ú Î≥ÄÌôò
      return `${(value / 1000).toFixed(1)}s`;
    } else if (metricName.includes('rate') || metricName.includes('percent') || metricName.includes('Rate')) {
      // ÎπÑÏú® Î©îÌä∏Î¶≠ÏùÄ ÌçºÏÑºÌä∏Î°ú ÌëúÏãú
      return `${(value * 100).toFixed(1)}%`;
    } else if (metricName.includes('count') || metricName.includes('length') || metricName.includes('Count')) {
      // Ïπ¥Ïö¥Ìä∏ Î©îÌä∏Î¶≠ÏùÄ Ï†ïÏàòÎ°ú ÌëúÏãú
      return Math.round(value).toString();
    } else {
      // Í∏∞Î≥∏ ÏÜåÏàòÏ†ê 2ÏûêÎ¶¨
      return value.toFixed(2);
    }
  }
}

/**
 * Notification Manager
 * Handles sending notifications to different channels
 */
class NotificationManager {
  private channels: Map<string, NotificationChannel> = new Map();
  private logger: StructuredLogger;

  constructor(logger: StructuredLogger) {
    this.logger = logger;
    this.initializeChannels();
  }

  /**
   * ÏïåÎ¶º Ï±ÑÎÑê Ï¥àÍ∏∞Ìôî
   */
  private initializeChannels(): void {
    // ÏΩòÏÜî Ï±ÑÎÑê
    this.channels.set('console', {
      name: 'Console',
      type: 'console',
      config: { colorOutput: true },
      enabled: true
    });

    // ÏõπÌõÖ Ï±ÑÎÑê (ÏòàÏãú)
    this.channels.set('webhook', {
      name: 'Webhook',
      type: 'webhook',
      config: { 
        url: process.env.ALERT_WEBHOOK_URL || 'https://example.com/webhook',
        timeout: 5000 
      },
      enabled: !!process.env.ALERT_WEBHOOK_URL
    });

    // Ïù¥Î©îÏùº Ï±ÑÎÑê (ÏòàÏãú)
    this.channels.set('email', {
      name: 'Email',
      type: 'email',
      config: {
        smtpHost: process.env.SMTP_HOST,
        smtpPort: process.env.SMTP_PORT,
        smtpUser: process.env.SMTP_USER,
        smtpPass: process.env.SMTP_PASS,
        fromEmail: process.env.ALERT_FROM_EMAIL,
        toEmails: process.env.ALERT_TO_EMAILS?.split(',') || []
      },
      enabled: !!(process.env.SMTP_HOST && process.env.ALERT_FROM_EMAIL)
    });

    console.log(`üì´ Initialized ${this.channels.size} notification channels`);
  }

  /**
   * ÏïåÎ¶º Ï†ÑÏÜ°
   */
  async sendNotification(
    channels: string[],
    alert: Omit<AlertEvent, 'notificationsSent'>
  ): Promise<{ channel: string; success: boolean; error?: string }[]> {
    const results: { channel: string; success: boolean; error?: string }[] = [];

    for (const channelName of channels) {
      const channel = this.channels.get(channelName);
      if (!channel || !channel.enabled) {
        results.push({
          channel: channelName,
          success: false,
          error: 'Channel not found or disabled'
        });
        continue;
      }

      try {
        await this.sendToChannel(channel, alert);
        results.push({ channel: channelName, success: true });
        
        // ÏÑ±Í≥µ Î°úÍ∑∏
        this.logger.log('INFO', 'alert', 'notification_sent', 
          `Alert notification sent to ${channelName}`, 
          { correlationId: alert.id },
          { alertId: alert.id, channel: channelName, severity: alert.severity }
        );
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        results.push({
          channel: channelName,
          success: false,
          error: errorMessage
        });

        // Ïã§Ìå® Î°úÍ∑∏
        this.logger.log('ERROR', 'alert', 'notification_failed',
          `Failed to send alert notification to ${channelName}: ${errorMessage}`,
          { correlationId: alert.id },
          { alertId: alert.id, channel: channelName, error: errorMessage }
        );
      }
    }

    return results;
  }

  /**
   * ÌäπÏ†ï Ï±ÑÎÑêÎ°ú ÏïåÎ¶º Ï†ÑÏÜ°
   */
  private async sendToChannel(channel: NotificationChannel, alert: Omit<AlertEvent, 'notificationsSent'>): Promise<void> {
    switch (channel.type) {
      case 'console':
        this.sendToConsole(alert);
        break;
      case 'webhook':
        await this.sendToWebhook(channel, alert);
        break;
      case 'email':
        await this.sendToEmail(channel, alert);
        break;
      default:
        throw new Error(`Unsupported channel type: ${channel.type}`);
    }
  }

  /**
   * ÏΩòÏÜî Ï∂úÎ†•
   */
  private sendToConsole(alert: Omit<AlertEvent, 'notificationsSent'>): void {
    const severityEmoji = this.getSeverityEmoji(alert.severity);
    const timestamp = alert.triggeredAt.toISOString();
    
    console.log(`\nüö® ${severityEmoji} ALERT TRIGGERED`);
    console.log(`‚îú‚îÄ Rule: ${alert.ruleName}`);
    console.log(`‚îú‚îÄ Severity: ${alert.severity.toUpperCase()}`);
    console.log(`‚îú‚îÄ Category: ${alert.category}`);
    console.log(`‚îú‚îÄ Message: ${alert.message}`);
    console.log(`‚îú‚îÄ Value: ${alert.metricValue} (threshold: ${alert.threshold})`);
    console.log(`‚îú‚îÄ Time: ${timestamp}`);
    console.log(`‚îî‚îÄ Alert ID: ${alert.id}\n`);
  }

  /**
   * ÏõπÌõÖ Ï†ÑÏÜ°
   */
  private async sendToWebhook(channel: NotificationChannel, alert: Omit<AlertEvent, 'notificationsSent'>): Promise<void> {
    const payload = {
      alertId: alert.id,
      ruleName: alert.ruleName,
      severity: alert.severity,
      category: alert.category,
      message: alert.message,
      metricValue: alert.metricValue,
      threshold: alert.threshold,
      condition: alert.condition,
      triggeredAt: alert.triggeredAt.toISOString(),
      context: alert.context
    };

    try {
      const response = await fetch(channel.config.url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'User-Agent': 'AI-Face-Chat-Alert-System/1.0'
        },
        body: JSON.stringify(payload),
        signal: AbortSignal.timeout(channel.config.timeout || 5000)
      });

      if (!response.ok) {
        throw new Error(`Webhook returned ${response.status}: ${response.statusText}`);
      }
    } catch (error) {
      if (error instanceof Error && error.name === 'TimeoutError') {
        throw new Error('Webhook request timed out');
      }
      throw error;
    }
  }

  /**
   * Ïù¥Î©îÏùº Ï†ÑÏÜ°
   */
  private async sendToEmail(channel: NotificationChannel, alert: Omit<AlertEvent, 'notificationsSent'>): Promise<void> {
    // Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî nodemailer Îì±Ïùò ÎùºÏù¥Î∏åÎü¨Î¶¨ ÏÇ¨Ïö©
    console.log('üìß Email notification (simulated):', {
      to: channel.config.toEmails,
      subject: `[${alert.severity.toUpperCase()}] ${alert.ruleName}`,
      body: this.generateEmailBody(alert)
    });
  }

  /**
   * Ïù¥Î©îÏùº Î≥∏Î¨∏ ÏÉùÏÑ±
   */
  private generateEmailBody(alert: Omit<AlertEvent, 'notificationsSent'>): string {
    return `
Alert Notification - ${alert.ruleName}

Severity: ${alert.severity.toUpperCase()}
Category: ${alert.category}
Message: ${alert.message}

Details:
- Metric Value: ${alert.metricValue}
- Threshold: ${alert.threshold}
- Condition: ${alert.condition}
- Triggered At: ${alert.triggeredAt.toISOString()}

Context:
- Metric Type: ${alert.context.metricType}
- Metric Name: ${alert.context.metricName}
- Evaluation Window: ${alert.context.evaluationWindow}

Alert ID: ${alert.id}

---
AI Face Chat Monitoring System
    `.trim();
  }

  /**
   * Ïã¨Í∞ÅÎèÑÎ≥Ñ Ïù¥Î™®ÏßÄ
   */
  private getSeverityEmoji(severity: string): string {
    switch (severity) {
      case 'critical': return 'üî•';
      case 'high': return 'üö®';
      case 'medium': return '‚ö†Ô∏è';
      case 'low': return 'üí°';
      default: return 'üì¢';
    }
  }

  /**
   * ÌôúÏÑ± Ï±ÑÎÑê Î™©Î°ù Ï°∞Ìöå
   */
  getActiveChannels(): string[] {
    return Array.from(this.channels.entries())
      .filter(([_, channel]) => channel.enabled)
      .map(([name, _]) => name);
  }
}

/**
 * Alert Manager
 * Manages active alerts and their lifecycle
 */
class AlertManager {
  private activeAlerts: Map<string, AlertEvent> = new Map();
  private alertHistory: AlertEvent[] = [];
  private readonly maxHistorySize = 1000;

  /**
   * ÏÉà ÏïåÎ¶º Ïù¥Î≤§Ìä∏ ÏÉùÏÑ±
   */
  createAlert(
    rule: AlertRule,
    metricValue: number,
    message: string
  ): AlertEvent {
    const id = `alert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    const alert: AlertEvent = {
      id,
      ruleId: rule.id,
      ruleName: rule.name,
      severity: rule.severity,
      category: rule.category,
      message,
      metricValue,
      threshold: rule.threshold,
      condition: rule.condition,
      triggeredAt: new Date(),
      context: {
        metricType: rule.metricType,
        metricName: rule.metricName,
        evaluationWindow: rule.evaluationWindow,
        additionalData: {
          tags: rule.tags,
          description: rule.description
        }
      },
      notificationsSent: [],
      escalationLevel: 0
    };

    this.activeAlerts.set(id, alert);
    return alert;
  }

  /**
   * ÏïåÎ¶ºÏóê ÎÖ∏Ìã∞ÌîºÏºÄÏù¥ÏÖò Í∏∞Î°ù Ï∂îÍ∞Ä
   */
  addNotificationRecord(
    alertId: string,
    channel: string,
    success: boolean,
    error?: string
  ): void {
    const alert = this.activeAlerts.get(alertId);
    if (!alert) return;

    alert.notificationsSent.push({
      channel,
      sentAt: new Date(),
      success,
      error
    });
  }

  /**
   * ÌôúÏÑ± ÏïåÎ¶º Ï°∞Ìöå
   */
  getActiveAlerts(): AlertEvent[] {
    return Array.from(this.activeAlerts.values());
  }

  /**
   * Ïã¨Í∞ÅÎèÑÎ≥Ñ ÌôúÏÑ± ÏïåÎ¶º Ï°∞Ìöå
   */
  getActiveAlertsBySeverity(severity: AlertEvent['severity']): AlertEvent[] {
    return this.getActiveAlerts().filter(alert => alert.severity === severity);
  }

  /**
   * ÌÜµÍ≥Ñ Ï°∞Ìöå
   */
  getAlertStatistics(): {
    activeCount: number;
    totalToday: number;
    criticalCount: number;
    averageResolutionTime: number;
    topCategories: { category: string; count: number }[];
  } {
    const active = this.getActiveAlerts();
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const todayAlerts = this.alertHistory.filter(alert => 
      alert.triggeredAt >= today
    );

    const critical = active.filter(alert => alert.severity === 'critical');

    // Ìï¥Í≤∞ ÏãúÍ∞Ñ ÌèâÍ∑† Í≥ÑÏÇ∞
    const resolvedAlerts = this.alertHistory.filter(alert => alert.resolvedAt);
    const resolutionTimes = resolvedAlerts.map(alert => 
      alert.resolvedAt!.getTime() - alert.triggeredAt.getTime()
    );
    const averageResolutionTime = resolutionTimes.length > 0
      ? resolutionTimes.reduce((sum, time) => sum + time, 0) / resolutionTimes.length
      : 0;

    // Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ ÌÜµÍ≥Ñ
    const categoryCount: Record<string, number> = {};
    for (const alert of [...active, ...todayAlerts]) {
      categoryCount[alert.category] = (categoryCount[alert.category] || 0) + 1;
    }

    const topCategories = Object.entries(categoryCount)
      .map(([category, count]) => ({ category, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 5);

    return {
      activeCount: active.length,
      totalToday: todayAlerts.length,
      criticalCount: critical.length,
      averageResolutionTime: averageResolutionTime / (1000 * 60), // minutes
      topCategories
    };
  }
}

/**
 * Alert System
 * Main class that orchestrates the entire alert system
 */
export class AlertSystem {
  private ruleManager: AlertRuleManager;
  private evaluator: AlertEvaluator;
  private notificationManager: NotificationManager;
  private alertManager: AlertManager;
  private logger: StructuredLogger;
  
  private evaluationTimer: NodeJS.Timeout | null = null;
  private readonly evaluationIntervalMs = 60 * 1000; // 1Î∂ÑÎßàÎã§ ÌèâÍ∞Ä

  constructor() {
    this.logger = getStructuredLogger();
    this.ruleManager = new AlertRuleManager();
    this.evaluator = new AlertEvaluator(getMetricsCollector());
    this.notificationManager = new NotificationManager(this.logger);
    this.alertManager = new AlertManager();

    this.startPeriodicEvaluation();

    console.log('üö® AlertSystem initialized');
  }

  /**
   * Ï£ºÍ∏∞Ï†Å ÏïåÎ¶º ÌèâÍ∞Ä ÏãúÏûë
   */
  private startPeriodicEvaluation(): void {
    this.evaluationTimer = setInterval(async () => {
      await this.evaluateAllRules();
    }, this.evaluationIntervalMs);

    console.log(`‚è∞ Started periodic alert evaluation (every ${this.evaluationIntervalMs / 1000}s)`);
  }

  /**
   * Î™®Îì† ÏïåÎ¶º Í∑úÏπô ÌèâÍ∞Ä
   */
  async evaluateAllRules(): Promise<void> {
    const activeRules = this.ruleManager.getActiveRules();
    
    for (const rule of activeRules) {
      try {
        // Ïø®Îã§Ïö¥ ÌôïÏù∏
        if (this.ruleManager.isInCooldown(rule)) {
          continue;
        }

        // Í∑úÏπô ÌèâÍ∞Ä
        const evaluation = await this.evaluator.evaluateRule(rule);
        
        if (evaluation.triggered && evaluation.message) {
          await this.handleTriggeredRule(rule, evaluation.value!, evaluation.message);
        }
      } catch (error) {
        this.logger.log('ERROR', 'alert', 'rule_evaluation_error',
          `Failed to evaluate rule ${rule.name}: ${error}`,
          undefined,
          { ruleId: rule.id, ruleName: rule.name, error: String(error) }
        );
      }
    }
  }

  /**
   * Ìä∏Î¶¨Í±∞Îêú Í∑úÏπô Ï≤òÎ¶¨
   */
  private async handleTriggeredRule(rule: AlertRule, metricValue: number, message: string): Promise<void> {
    // ÏïåÎ¶º Ïù¥Î≤§Ìä∏ ÏÉùÏÑ±
    const alert = this.alertManager.createAlert(rule, metricValue, message);

    // ÎßàÏßÄÎßâ Ìä∏Î¶¨Í±∞ ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏
    this.ruleManager.updateLastTriggered(rule.id);

    // ÏïåÎ¶º Î°úÍπÖ
    this.logger.log('WARN', 'alert', 'alert_triggered',
      `Alert triggered: ${rule.name}`,
      { correlationId: alert.id },
      {
        alertId: alert.id,
        ruleId: rule.id,
        ruleName: rule.name,
        severity: rule.severity,
        category: rule.category,
        metricValue,
        threshold: rule.threshold,
        condition: rule.condition
      }
    );

    // ÏïåÎ¶º Ï†ÑÏÜ°
    await this.sendAlert(alert, rule.notificationChannels);
  }

  /**
   * ÏïåÎ¶º Ï†ÑÏÜ°
   */
  private async sendAlert(alert: AlertEvent, channels: string[]): Promise<void> {
    try {
      const results = await this.notificationManager.sendNotification(channels, alert);
      
      // Ï†ÑÏÜ° Í≤∞Í≥º Í∏∞Î°ù
      for (const result of results) {
        this.alertManager.addNotificationRecord(
          alert.id,
          result.channel,
          result.success,
          result.error
        );
      }

      const successCount = results.filter(r => r.success).length;
      console.log(`üì§ Alert notifications sent: ${successCount}/${results.length} successful (${alert.id})`);

    } catch (error) {
      this.logger.log('ERROR', 'alert', 'notification_error',
        `Failed to send alert notifications: ${error}`,
        { correlationId: alert.id },
        { alertId: alert.id, error: String(error) }
      );
    }
  }

  /**
   * ÏïåÎ¶º Í∑úÏπô Í¥ÄÎ¶¨
   */
  getRuleManager(): AlertRuleManager {
    return this.ruleManager;
  }

  /**
   * ÏïåÎ¶º Í¥ÄÎ¶¨
   */
  getAlertManager(): AlertManager {
    return this.alertManager;
  }

  /**
   * ÎÖ∏Ìã∞ÌîºÏºÄÏù¥ÏÖò Í¥ÄÎ¶¨
   */
  getNotificationManager(): NotificationManager {
    return this.notificationManager;
  }

  /**
   * ÏãúÏä§ÌÖú ÏÉÅÌÉú Ï°∞Ìöå
   */
  getSystemStatus(): {
    activeRules: number;
    activeAlerts: number;
    criticalAlerts: number;
    notificationChannels: string[];
    lastEvaluationTime: Date;
    statistics: ReturnType<AlertManager['getAlertStatistics']>;
  } {
    return {
      activeRules: this.ruleManager.getActiveRules().length,
      activeAlerts: this.alertManager.getActiveAlerts().length,
      criticalAlerts: this.alertManager.getActiveAlertsBySeverity('critical').length,
      notificationChannels: this.notificationManager.getActiveChannels(),
      lastEvaluationTime: new Date(),
      statistics: this.alertManager.getAlertStatistics()
    };
  }

  /**
   * ÏãúÏä§ÌÖú Ï§ëÏßÄ
   */
  stop(): void {
    if (this.evaluationTimer) {
      clearInterval(this.evaluationTimer);
      this.evaluationTimer = null;
    }

    console.log('üö® AlertSystem stopped');
  }
}

/**
 * Singleton instance management
 */
let globalAlertSystem: AlertSystem | null = null;

/**
 * Get or create global alert system instance
 */
export function getAlertSystem(): AlertSystem {
  if (!globalAlertSystem) {
    globalAlertSystem = new AlertSystem();
  }
  return globalAlertSystem;
}

/**
 * Helper functions for alert management
 */
export const AlertUtils = {
  /**
   * Í∏¥Í∏â ÏïåÎ¶º ÏÉùÏÑ± (ÏàòÎèô)
   */
  createEmergencyAlert: (message: string, severity: 'high' | 'critical' = 'high') => {
    const alertSystem = getAlertSystem();
    const ruleManager = alertSystem.getRuleManager();
    
    const emergencyRuleId = ruleManager.addRule({
      name: 'Emergency Alert',
      description: 'Manually triggered emergency alert',
      category: 'system_health',
      severity,
      metricType: 'quality',
      metricName: 'emergency_metric',
      condition: 'greater_than',
      threshold: 0,
      evaluationWindow: 'last_5min',
      cooldownMinutes: 0,
      notificationChannels: ['console', 'webhook', 'email'],
      tags: { manual: 'true', emergency: 'true' },
      enabled: true
    });

    return emergencyRuleId;
  },

  /**
   * ÏïåÎ¶º ÌÜµÍ≥Ñ Ï°∞Ìöå
   */
  getAlertStatistics: () => {
    const alertSystem = getAlertSystem();
    return alertSystem.getAlertManager().getAlertStatistics();
  },

  /**
   * ÌôúÏÑ± ÏïåÎ¶º ÏöîÏïΩ
   */
  getActiveAlertsSummary: () => {
    const alertSystem = getAlertSystem();
    const alertManager = alertSystem.getAlertManager();
    
    const active = alertManager.getActiveAlerts();
    const bySeverity = {
      critical: active.filter(a => a.severity === 'critical').length,
      high: active.filter(a => a.severity === 'high').length,
      medium: active.filter(a => a.severity === 'medium').length,
      low: active.filter(a => a.severity === 'low').length
    };

    const byCategory: Record<string, number> = {};
    for (const alert of active) {
      byCategory[alert.category] = (byCategory[alert.category] || 0) + 1;
    }

    return {
      total: active.length,
      bySeverity,
      byCategory,
      oldest: active.length > 0 ? Math.min(...active.map(a => a.triggeredAt.getTime())) : null,
      unacknowledged: active.filter(a => !a.acknowledgedAt).length
    };
  },

  /**
   * ÏãúÏä§ÌÖú Ìó¨Ïä§ Ï≤¥ÌÅ¨
   */
  performHealthCheck: async () => {
    const alertSystem = getAlertSystem();
    const status = alertSystem.getSystemStatus();
    
    const healthCheck = {
      alertSystemStatus: 'healthy' as 'healthy' | 'degraded' | 'critical',
      issues: [] as string[],
      ...status
    };

    // ÏÉÅÌÉú ÌèâÍ∞Ä
    if (status.criticalAlerts > 0) {
      healthCheck.alertSystemStatus = 'critical';
      healthCheck.issues.push(`${status.criticalAlerts} critical alerts active`);
    } else if (status.activeAlerts > 10) {
      healthCheck.alertSystemStatus = 'degraded';
      healthCheck.issues.push(`High number of active alerts: ${status.activeAlerts}`);
    }

    if (status.notificationChannels.length === 0) {
      healthCheck.alertSystemStatus = 'degraded';
      healthCheck.issues.push('No notification channels available');
    }

    return healthCheck;
  }
};
